$def with (master, glyphid, A_glyphjson, B_glyphjson, M_glyphjson)
<title>
Project $master.FontName
</title>
<link rel="stylesheet" type="text/css" href="/static/mfg.css"/>
<script src="http://cdnjs.cloudflare.com/ajax/libs/paper.js/0.9.9/paper.js"></script>

<div class="row">
  <div class="col-md-4">
    <h4>Font A</h4>
    <canvas id="canvas-a" width="400" height="400"></canvas>

    <div class="well">
      <h4>Parameters Font A <small><a href="/view/$master.FontName/$glyphid/settings/">change</a></small></h4>

      $if not master.idlocalA:
        <div class="label label-danger">This font has not specified local parameters</div>
    </div>
  </div>

  <div class="col-md-4" style="border: solid 2px black;">
    <h4>Metapolation</h4>
    <canvas width="400" height="400" id="canvas-m"></canvas>

    <div class="well">
      <h4>Global Parameters <small><a href="/view/$master.FontName/$glyphid/settings/">change</a></small></h4>
    </div>
  </div>

  <div class="col-md-4">
    <h4>Font B</h4>
    <canvas id="canvas-b" height="400" width="400"></canvas>

    <div class="well">
      <h4>Parameters Font B <small><a href="/view/$master.FontName/$glyphid/settings/">change</a></small></h4>
      $if not master.idlocalB:
        <div class="label label-danger">This font has not specified local parameters</div>
    </div>
  </div>
</div>


<script type="text/paperscript" canvas="canvas-m">
  function setText(point) {
      var text = new PointText(point);
      text.fillColor = 'black';
      text.content = point.x.toFixed(2) + ',' + point.y.toFixed(2);
  }

  var EDGE_JSON = $:M_glyphjson;

  function getPoint(x, y) {
    width = EDGE_JSON.width;
    height = EDGE_JSON.height;

    ratio = width / height;
    if (width > height) {
      w = scope.view.size.width - 100;
      h = w / ratio;
    } else {
      h = scope.view.size.height - 100;
      w = h * ratio;
    }
    nx = w * x / width;
    ny = h * y / height;

    var point = new Point(nx, ny);
    point.data = {'name': 'p' + x}
    return point
  }

  var types = ['point', 'handleIn', 'handleOut'];

  var edges = EDGE_JSON.edges;
  for (var i = 0; i < edges.length; i++) {
      for (var j = 0; j < edges[i].contours.length; j++) {
          var path = new Path();
          var contours = edges[i].contours[j];
          for (var k = 0; k < contours.length; k++) { // contours.length
              contour = contours[k];
              console.log(contour);

              var point = getPoint(Number(contour.x), 500 - Number(contour.y));
              var handleIn = getPoint(Number(contour.controls[0].x) - Number(contour.x),
                                       Number(contour.y) - Number(contour.controls[0].y));
              var handleOut = getPoint(Number(contour.controls[1].x) - Number(contour.x),
                                        Number(contour.y) - Number(contour.controls[1].y));
              segment = new Segment(point, handleIn, handleOut);
              // setText(point);
              path.add(segment);
          }
          path.closed = true;
          path.selected = true;
          path.fullySelected = true;
          path.strokeColor = 'black';
          path.position.y += +200;
          path.fillColor = {
              hue: 360 * Math.random(),
              saturation: 1,
              brightness: 1,
              alpha: 0.5
          };

          var circle = new Path.Circle({
            center: new Point(306.0, 714- 419.0),
            radius: 10,
            fillColor: 'red', 

          });

          var currentSegment, mode, type;
          path.onMouseDown = function(event) {
              if (currentSegment)
                  currentSegment.selected = false;
              mode = type = currentSegment = null;

              var result = findHandle(path, event.point);
              
              if (result) {
                  currentSegment = result.segment;
                  type = result.type;
                  if (path.segments.length > 1 && result.type == 'point'
                        && result.segment.index == 0) {
                      mode = 'close';
                      path.closed = true;
                      path.selected = true;
                  }
              }

              if (mode != 'close') {
                  mode = currentSegment ? 'move' : 'add';
                  if (currentSegment) {
                    currentSegment.point = event.point;
                  }
                  box.position = event.point;               
                  
              }
          }

          function onMouseDrag(event) {
              if (!currentSegment) {
                return;
              }
              if (mode == 'move' && type == 'point') {
                  currentSegment.point = event.point;
                  box.position = event.point;
              } else if (mode != 'close') {
                  var delta = event.delta.clone();
                  if (type == 'handleOut' || mode == 'add')
                      delta = -delta;
                  currentSegment.handleIn += delta;
                  currentSegment.handleOut -= delta;
                }
          }
      }

      var box = new Path.Rectangle(new Point(50, 50), new Size(50, 50));
      box.style = {
          strokeColor: 'red',
          strokeWidth: '5'
      };

      function onFrame(event) {
        // Each frame, rotate the copy by 1 degree:
        box.rotate(1);
      } 
  }

  function findHandle(path, point) {
    for (var i = 0, l = path.segments.length; i < l; i++) {
        for (var j = 0; j < 30; j++) {
            var type = types[j];
            var segment = path.segments[i];
            var segmentPoint = type == 'point'
                  ? segment.point
                  : segment.point + segment[type];
            var distance = (point - segmentPoint).length;
            if (distance < 10) {
                return {
                    type: type,
                    segment: segment
                };
            } 
        }
    }
    return null;
  }
</script>


<script type="text/paperscript" canvas="canvas-a">
  function setText(point) {
      var text = new PointText(point);
      text.fillColor = 'black';
      text.content = point.x.toFixed(2) + ',' + point.y.toFixed(2);
  }

  var EDGE_JSON = $:A_glyphjson;

  function getPoint(x, y, i) {
    width = EDGE_JSON.width;
    height = EDGE_JSON.height;

    ratio = width / height;
    if (width > height) {
      w = scope.view.size.width - 100;
      h = w / ratio;
    } else {
      h = scope.view.size.height - 100;
      w = h * ratio;
    }
    nx = w * x / width;
    ny = h * y / height;

    return new Point(nx, ny);
  }
  
  var types = ['point', 'handleIn', 'handleOut'];

  var edges = EDGE_JSON.edges;
  for (var i = 0; i < edges.length; i++) {
      for (var j = 0; j < edges[i].contours.length; j++) {
          var path = new Path();
          var contours = edges[i].contours[j];
          for (var k = 0; k < contours.length; k++) { // contours.length
              contour = contours[k];
              console.log(contour);

              var point = getPoint(Number(contour.x), 500 - Number(contour.y));
              var handleIn = getPoint(Number(contour.controls[0].x) - Number(contour.x),
                                       Number(contour.y) - Number(contour.controls[0].y));
              var handleOut = getPoint(Number(contour.controls[1].x) - Number(contour.x),
                                        Number(contour.y) - Number(contour.controls[1].y));
              segment = new Segment(point, handleIn, handleOut);
              // setText(point);
              path.add(segment);
          }
          path.closed = true;
          path.selected = true;
          path.fullySelected = true;
          path.strokeColor = 'black';
          path.position.y += +200;
          path.fillColor = {
              hue: 360 * Math.random(),
              saturation: 1,
              brightness: 1,
              alpha: 0.5
          };

          var circle = new Path.Circle({
            center: new Point(306.0, 714- 419.0),
            radius: 10,
            fillColor: 'red', 

          });

          var currentSegment, mode, type;
          path.onMouseDown = function(event) {
              if (currentSegment)
                  currentSegment.selected = false;
              mode = type = currentSegment = null;

              var result = findHandle(path, event.point);
              
              if (result) {
                  currentSegment = result.segment;
                  type = result.type;
                  if (path.segments.length > 1 && result.type == 'point'
                        && result.segment.index == 0) {
                      mode = 'close';
                      path.closed = true;
                      path.selected = true;
                  }
              }

              if (mode != 'close') {
                  mode = currentSegment ? 'move' : 'add';
                  if (currentSegment) {
                    currentSegment.point = event.point;
                  }
                  box.position = event.point;               
                  
              }
          }

          function onMouseDrag(event) {
              if (!currentSegment) {
                return;
              }
              if (mode == 'move' && type == 'point') {
                  currentSegment.point = event.point;
                  box.position = event.point;
              } else if (mode != 'close') {
                  var delta = event.delta.clone();
                  if (type == 'handleOut' || mode == 'add')
                      delta = -delta;
                  currentSegment.handleIn += delta;
                  currentSegment.handleOut -= delta;
                }
          }
      }

      var box = new Path.Rectangle(new Point(50, 50), new Size(50, 50));
      box.style = {
          strokeColor: 'red',
          strokeWidth: '5'
      };

      function onFrame(event) {
        // Each frame, rotate the copy by 1 degree:
        box.rotate(1);
      } 
  }

  function findHandle(path, point) {
    for (var i = 0, l = path.segments.length; i < l; i++) {
        for (var j = 0; j < 30; j++) {
            var type = types[j];
            var segment = path.segments[i];
            var segmentPoint = type == 'point'
                  ? segment.point
                  : segment.point + segment[type];
            var distance = (point - segmentPoint).length;
            if (distance < 10) {
                return {
                    type: type,
                    segment: segment
                };
            } 
        }
    }
    return null;
  }
</script>


<script type="text/paperscript" canvas="canvas-b">
function setText(point) {
      var text = new PointText(point);
      text.fillColor = 'black';
      text.content = point.x.toFixed(2) + ',' + point.y.toFixed(2);
  }

  var EDGE_JSON = $:B_glyphjson;

  function getPoint(x, y) {
    width = EDGE_JSON.width;
    height = EDGE_JSON.height;

    ratio = width / height;
    if (width > height) {
      w = scope.view.size.width - 100;
      h = w / ratio;
    } else {
      h = scope.view.size.height - 100;
      w = h * ratio;
    }
    nx = w * x / width;
    ny = h * y / height;

    console.log({'nx': nx, 'ny': ny})
    return new Point(nx, ny);
  }

  var edges = EDGE_JSON.edges;
  for (var i = 0; i < edges.length; i++) {
      for (var j = 0; j < edges[i].contours.length; j++) {
          var path = new Path();
          var contours = edges[i].contours[j];
          for (var k = 0; k < contours.length; k++) { // contours.length
              contour = contours[k];
              console.log(contour);

              var point = getPoint(Number(contour.x), 500 - Number(contour.y));
              var handleIn = getPoint(Number(contour.controls[0].x) - Number(contour.x),
                                       Number(contour.y) - Number(contour.controls[0].y));
              var handleOut = getPoint(Number(contour.controls[1].x) - Number(contour.x),
                                        Number(contour.y) - Number(contour.controls[1].y));
              segment = new Segment(point, handleIn, handleOut);
              // setText(point);
              path.add(segment);
          }
          path.closed = true;
          path.selected = true;
          path.fullySelected = true;
          path.strokeColor = 'black';
          path.position.y += +200;
          path.fillColor = {
              hue: 360 * Math.random(),
              saturation: 1,
              brightness: 1,
              alpha: 0.5
          };
      }
  }
  </script>
