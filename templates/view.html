$def with (master, glyphid, A_glyphjson, B_glyphjson, M_glyphjson, localparametersA, localparametersB, origins)
<title>
Project $master.fontname
</title>
<link rel="stylesheet" type="text/css" href="/static/mfg.css"/>
<script src="http://cdnjs.cloudflare.com/ajax/libs/paper.js/0.9.9/paper.js"></script>

<div class="row">
  <div class="col-md-4">
    <h4>Font A</h4>
    <canvas id="canvas-a" width="400" height="400"></canvas>

    <div class="well">
      <h4>Parameters Font A <small><a href="/view/$master.fontname/$glyphid/settings/">change</a></small></h4>

      $if not localparametersA:
        <div class="label label-danger">This font has not specified local parameters</div>
      $else:
        <div style="font-family: monospace;">
          px: $localparametersA.px<br />
          width: $localparametersA.width<br />
          space: $localparametersA.space<br />
          xheight: $localparametersA.xheight<br />
          capital: $localparametersA.capital<br />
          boxheight: $localparametersA.boxheight<br />
          ascender: $localparametersA.ascender<br />
          descender: $localparametersA.descender<br />
          inktrap: $localparametersA.inktrap<br />
          stemcut: $localparametersA.stemcut<br />
          skeleton: $localparametersA.skeleton<br />
          superness: $localparametersA.superness<br />
          over: $localparametersA.over
        </div>
    </div>
  </div>

  <div class="col-md-4" style="border: solid 2px black;">
    <h4>Metapolation</h4>
    <canvas width="400" height="400" id="canvas-m"></canvas>

    <div class="well">
      <h4>Global Parameters <small><a href="/view/$master.fontname/$glyphid/settings/">change</a></small></h4>
    </div>
  </div>

  <div class="col-md-4">
    <h4>Font B</h4>
    <canvas id="canvas-b" height="400" width="400"></canvas>

    <div class="well">
      <h4>Parameters Font B <small><a href="/view/$master.fontname/$glyphid/settings/">change</a></small></h4>
      $if not localparametersB:
        <div class="label label-danger">This font has not specified local parameters</div>
      $else:
        <div style="font-family: monospace;">
          px: $localparametersB.px<br />
          width: $localparametersB.width<br />
          space: $localparametersB.space<br />
          xheight: $localparametersB.xheight<br />
          capital: $localparametersB.capital<br />
          boxheight: $localparametersB.boxheight<br />
          ascender: $localparametersB.ascender<br />
          descender: $localparametersB.descender<br />
          inktrap: $localparametersB.inktrap<br />
          stemcut: $localparametersB.stemcut<br />
          skeleton: $localparametersB.skeleton<br />
          superness: $localparametersB.superness<br />
          over: $localparametersB.over
        </div>
    </div>
  </div>
</div>


<script type="text/paperscript" canvas="canvas-m">
  function setText(point) {
      var text = new PointText(point);
      text.fillColor = 'black';
      text.content = point.x.toFixed(2) + ',' + point.y.toFixed(2);
  }

  var EDGE_JSON = $:M_glyphjson;

  function getPoint(x, y) {
    width = EDGE_JSON.width;
    height = EDGE_JSON.height;

    ratio = width / height;
    if (width > height) {
      w = scope.view.size.width - 100;
      h = w / ratio;
    } else {
      h = scope.view.size.height - 100;
      w = h * ratio;
    }
    nx = w * x / width;
    ny = h * y / height;

    return new Point(nx, ny)
  }

  var types = ['point', 'handleIn', 'handleOut'];

  var edges = EDGE_JSON.edges;
  for (var i = 0; i < edges.length; i++) {
      for (var j = 0; j < edges[i].contours.length; j++) {
          var path = new Path();
          var contours = edges[i].contours[j];
          for (var k = 0; k < contours.length; k++) { // contours.length
              contour = contours[k];

              var point = getPoint(Number(contour.x), 500 - Number(contour.y));
              var handleIn = getPoint(Number(contour.controls[0].x) - Number(contour.x),
                                       Number(contour.y) - Number(contour.controls[0].y));
              var handleOut = getPoint(Number(contour.controls[1].x) - Number(contour.x),
                                        Number(contour.y) - Number(contour.controls[1].y));
              segment = new Segment(point, handleIn, handleOut);
              // setText(point);
              path.add(segment);
          }
          path.closed = true;
          path.selected = true;
          path.fullySelected = true;
          path.strokeColor = 'black';
          path.position.y += +200;
          path.fillColor = {
              hue: 360 * Math.random(),
              saturation: 1,
              brightness: 1,
              alpha: 0.5
          };

          var circle = new Path.Circle({
            center: new Point(306.0, 714- 419.0),
            radius: 10,
            fillColor: 'red', 

          });

          var currentSegment, mode, type;
          path.onMouseDown = function(event) {
              if (currentSegment)
                  currentSegment.selected = false;
              mode = type = currentSegment = null;

              var result = findHandle(this, event.point);
              
              if (result) {
                  currentSegment = result.segment;
                  type = result.type;
                  if (this.segments.length > 1 && result.type == 'point'
                        && result.segment.index == 0) {
                      mode = 'close';
                      this.closed = true;
                      this.selected = true;
                  }
              }

              if (mode != 'close') {
                  mode = currentSegment ? 'move' : 'add';
                  if (currentSegment) {
                    currentSegment.point = event.point;
                    box.position = event.point;
                  }
                  
              }
          }

          path.onMouseUp = function(event) {
            currentSegment = null;
          }

          function onMouseDrag(event) {
              if (!currentSegment) {
                return;
              }
              if (mode == 'move' && type == 'point') {
                  currentSegment.point = event.point;
                  box.position = event.point;
              } else if (mode != 'close') {
                  var delta = event.delta.clone();
                  if (type == 'handleOut' || mode == 'add')
                      delta = -delta;
                  currentSegment.handleIn += delta;
                  currentSegment.handleOut -= delta;
                }
          }
      }

      var box = new Path.Rectangle(new Point(50, 50), new Size(50, 50));
      box.style = {
          strokeColor: 'red',
          strokeWidth: '5'
      };

      function onFrame(event) {
        // Each frame, rotate the copy by 1 degree:
        box.rotate(1);
      } 
  }

  function findHandle(path, point) {
    for (var i = 0, l = path.segments.length; i < l; i++) {
        for (var j = 0; j < 30; j++) {
            var type = types[j];
            var segment = path.segments[i];
            var segmentPoint = type == 'point'
                  ? segment.point
                  : segment.point + segment[type];
            var distance = (point - segmentPoint).length;
            if (distance < 10) {
                return {
                    type: type,
                    segment: segment
                };
            } 
        }
    }
    return null;
  }
</script>


<script type="text/paperscript" canvas="canvas-a">
  function setText(point) {
      var text = new PointText(point);
      text.fillColor = 'black';
      text.content = point.x.toFixed(2) + ',' + point.y.toFixed(2);
  }

  var EDGE_JSON = $:A_glyphjson;

  var JSON = $:origins['a'];

  function getPoint(x, y, i) {
    width = EDGE_JSON.width;
    height = EDGE_JSON.height;

    var r = resize(x, y, EDGE_JSON.width, EDGE_JSON.height,
                   scope.view.size.width - 100, scope.view.size.height - 100)
    return new Point(r.x, r.y);
  }

  function resize(x, y, width, height, newwidth, newheight) {
    ratio = width / height;
    if (width > height) {
      w = newwidth;
      h = w / ratio;
    } else {
      h = newheight;
      w = h * ratio;
    }
    nx = w * x / width;
    ny = h * y / height;
    return {x: nx, y: ny}
  }

  var types = ['point', 'handleIn', 'handleOut'];

  var edges = EDGE_JSON.edges;
  var pathes = [];
  for (var i = 0; i < edges.length; i++) {
      for (var j = 0; j < edges[i].contours.length; j++) {
          var path = new Path();
          var contours = edges[i].contours[j];
          console.log(j + ' segment');
          for (var k = 0; k < contours.length; k++) { // contours.length
              contour = contours[k];
              console.log(k + ' (' + Number(contour.x) + ',' + Number(contour.y) + ')');
              var point = getPoint(Number(contour.x), 500 - Number(contour.y), k);
              var handleIn = getPoint(Number(contour.controls[0].x) - Number(contour.x),
                                       Number(contour.y) - Number(contour.controls[0].y));
              var handleOut = getPoint(Number(contour.controls[1].x) - Number(contour.x),
                                        Number(contour.y) - Number(contour.controls[1].y));
              segment = new Segment(point, handleIn, handleOut);
              // setText(point);
              path.add(segment);
          }
          path.closed = true;
          path.position.y += +200;
          path.fillColor = {
              hue: 360 * Math.random(),
              saturation: 1,
              brightness: 1,
              alpha: 0.5
          };
          pathes.push(path);
      }
  }

  for (var i = 0; i < JSON.points.length; i++) {
    segment = new Segment(getPoint(Number(JSON.points[i].x), 500 - Number(JSON.points[i].y), 0));
    path = new Path();
    path.add(segment);
    path.closed = true;
    path.selected = true;
    path.fullySelected = true;
    path.strokeColor = new Color(0.5, 0, 0.5);
    path.position.y += +200;
  }

  var circle = new Path.Circle({
    center: new Point(306.0, 714- 419.0),
    radius: 10,
    fillColor: 'red', 
  });

  var currentSegment, mode, type, pointnumber, pathnumber;

  function restore_original_coords(point) {
    var r = resize(point.x, point.y, scope.view.size.width - 100, scope.view.size.height - 100,
               EDGE_JSON.width, EDGE_JSON.height);
    console.log('pointnr: ' + pointnumber + ', path: ' + pathnumber);
    console.log(r.x + ', ' + (500 - r.y));
    return r;
  }

  function onMouseUp(event) {
    if (currentSegment) {
      var x = currentSegment.point.x;
      var y = currentSegment.point.y - 200;
      var xycoord = restore_original_coords(new Point(x, y));

      x = (currentSegment.point + currentSegment.handleIn).x;
      y = (currentSegment.point + currentSegment.handleIn).y - 200;
      var handleIn = restore_original_coords(new Point(x, y));

      x = (currentSegment.point + currentSegment.handleOut).x;
      y = (currentSegment.point + currentSegment.handleOut).y - 200;
      var handleOut = restore_original_coords(new Point(x, y));

      jQuery.post('', {pointid: pointnumber,
                       x: xycoord.x,
                       y: 500 - xycoord.y,
                       xIn: handleIn.x,
                       yIn: 500 - handleIn.y,
                       xOut: handleOut.x,
                       yOut: 500 - handleOut.y,
                       source: 'a',
                       segment: pathnumber});
    }
    currentSegment = null;
  }
  
  function onMouseDown(event) {
      mode = type = currentSegment = null;
      var result = findHandle(event.point);
      
      if (!result) 
        return;


      currentSegment = result.segment;
      type = result.type;
      path = result.path;
      pointnumber = result.pointnumber;
      pathnumber = result.pathnumber;
      
      if (path.segments.length > 1 && result.type == 'point'
            && result.segment.index == 0) {
          mode = 'close';
          path.closed = true;
          path.selected = true;
      }
      
      if (mode != 'close') {
          mode = currentSegment ? 'move' : 'add';
          if (currentSegment) {
            if (type != 'point') {
              box.position = currentSegment.point + currentSegment[type];
            }
          }
      }
  }

  function onMouseDrag(event) {
      if (!currentSegment) {
        return;
      }
      if (mode == 'move' && type == 'point') {
          currentSegment.point = event.point;
      } else if (mode != 'close') {
        var delta = event.delta.clone();
        if (type == 'handleOut' || mode == 'add')
            delta = -delta;
        currentSegment.handleIn += delta;
        currentSegment.handleOut -= delta;
      }
      // console.log(pointnumber);
      // console.log(currentSegment.point);
      box.position = type == 'point' ? currentSegment.point : currentSegment.point + currentSegment[type];
  }

  var box = new Path.Rectangle(new Point(50, 50), new Size(50, 50));
  box.style = {
      strokeColor: 'red',
      strokeWidth: '5'
  };

  function onFrame(event) {
    // Each frame, rotate the copy by 1 degree:
    box.rotate(1);
  } 

  function findHandle(p) {
    for (var k = 0; k < pathes.length; k++) {
      var path = pathes[k];
      for (var i = 0, l = path.segments.length; i < l; i++) {
          for (var j = 0; j < 3; j++) {
              var type = types[j];
              var segment = path.segments[i];
              var segmentPoint = type == 'point'
                  ? segment.point
                  : segment.point + segment[type];

              if ((p - segmentPoint).length < 3) {
                  return {
                      type: type,
                      segment: segment,
                      path: path,
                      pointnumber: i,
                      pathnumber: k
                  };
              }
          }
      }
    }
    return null;
  }
</script>


<script type="text/paperscript" canvas="canvas-b">
function setText(point) {
      var text = new PointText(point);
      text.fillColor = 'black';
      text.content = point.x.toFixed(2) + ',' + point.y.toFixed(2);
  }

  var EDGE_JSON = $:B_glyphjson;

  function getPoint(x, y, i) {
    width = EDGE_JSON.width;
    height = EDGE_JSON.height;

    var r = resize(x, y, EDGE_JSON.width, EDGE_JSON.height,
                   scope.view.size.width - 100, scope.view.size.height - 100)
    return new Point(r.x, r.y);
  }

  function resize(x, y, width, height, newwidth, newheight) {
    ratio = width / height;
    if (width > height) {
      w = newwidth;
      h = w / ratio;
    } else {
      h = newheight;
      w = h * ratio;
    }
    nx = w * x / width;
    ny = h * y / height;
    return {x: nx, y: ny}
  }

  var types = ['point', 'handleIn', 'handleOut'];

  var edges = EDGE_JSON.edges;
  var pathes = [];
  for (var i = 0; i < edges.length; i++) {
      for (var j = 0; j < edges[i].contours.length; j++) {
          var path = new Path();
          var contours = edges[i].contours[j];
          console.log(j + ' segment');
          for (var k = 0; k < contours.length; k++) { // contours.length
              contour = contours[k];
              console.log(k + ' (' + Number(contour.x) + ',' + Number(contour.y) + ')');
              var point = getPoint(Number(contour.x), 500 - Number(contour.y), k);
              var handleIn = getPoint(Number(contour.controls[0].x) - Number(contour.x),
                                       Number(contour.y) - Number(contour.controls[0].y));
              var handleOut = getPoint(Number(contour.controls[1].x) - Number(contour.x),
                                        Number(contour.y) - Number(contour.controls[1].y));
              segment = new Segment(point, handleIn, handleOut);
              // setText(point);
              path.add(segment);
          }
          path.closed = true;
          path.selected = true;
          path.fullySelected = true;
          path.strokeColor = 'black';
          path.position.y += +200;
          path.fillColor = {
              hue: 360 * Math.random(),
              saturation: 1,
              brightness: 1,
              alpha: 0.5
          };
          pathes.push(path);
      }
  }

  var circle = new Path.Circle({
    center: new Point(306.0, 714- 419.0),
    radius: 10,
    fillColor: 'red', 
  });

  var currentSegment, mode, type, pointnumber, pathnumber;

  function restore_original_coords(point) {
    var r = resize(point.x, point.y, scope.view.size.width - 100, scope.view.size.height - 100,
               EDGE_JSON.width, EDGE_JSON.height);
    console.log('pointnr: ' + pointnumber + ', path: ' + pathnumber);
    console.log(r.x + ', ' + (500 - r.y));
    return r;
  }

  function onMouseUp(event) {
    if (currentSegment) {
      var x = currentSegment.point.x;
      var y = currentSegment.point.y - 200;
      var xycoord = restore_original_coords(new Point(x, y));

      x = (currentSegment.point + currentSegment.handleIn).x;
      y = (currentSegment.point + currentSegment.handleIn).y - 200;
      var handleIn = restore_original_coords(new Point(x, y));

      x = (currentSegment.point + currentSegment.handleOut).x;
      y = (currentSegment.point + currentSegment.handleOut).y - 200;
      var handleOut = restore_original_coords(new Point(x, y));

      jQuery.post('', {pointid: pointnumber,
                       x: xycoord.x,
                       y: 500 - xycoord.y,
                       xIn: handleIn.x,
                       yIn: 500 - handleIn.y,
                       xOut: handleOut.x,
                       yOut: 500 - handleOut.y,
                       source: 'b',
                       segment: pathnumber});
    }
    currentSegment = null;
  }
  
  function onMouseDown(event) {
      mode = type = currentSegment = null;
      var result = findHandle(event.point);
      
      if (!result) 
        return;


      currentSegment = result.segment;
      type = result.type;
      path = result.path;
      pointnumber = result.pointnumber;
      pathnumber = result.pathnumber;
      
      if (path.segments.length > 1 && result.type == 'point'
            && result.segment.index == 0) {
          mode = 'close';
          path.closed = true;
          path.selected = true;
      }
      
      if (mode != 'close') {
          mode = currentSegment ? 'move' : 'add';
          if (currentSegment) {
            if (type != 'point') {
              box.position = currentSegment.point + currentSegment[type];
            }
          }
      }
  }

  function onMouseDrag(event) {
      if (!currentSegment) {
        return;
      }
      if (mode == 'move' && type == 'point') {
          currentSegment.point = event.point;
      } else if (mode != 'close') {
        var delta = event.delta.clone();
        if (type == 'handleOut' || mode == 'add')
            delta = -delta;
        currentSegment.handleIn += delta;
        currentSegment.handleOut -= delta;
      }
      // console.log(pointnumber);
      // console.log(currentSegment.point);
      box.position = type == 'point' ? currentSegment.point : currentSegment.point + currentSegment[type];
  }

  var box = new Path.Rectangle(new Point(50, 50), new Size(50, 50));
  box.style = {
      strokeColor: 'red',
      strokeWidth: '5'
  };

  function onFrame(event) {
    // Each frame, rotate the copy by 1 degree:
    box.rotate(1);
  } 

  function findHandle(p) {
    for (var k = 0; k < pathes.length; k++) {
      var path = pathes[k];
      for (var i = 0, l = path.segments.length; i < l; i++) {
          for (var j = 0; j < 3; j++) {
              var type = types[j];
              var segment = path.segments[i];
              var segmentPoint = type == 'point'
                  ? segment.point
                  : segment.point + segment[type];

              if ((p - segmentPoint).length < 3) {
                  return {
                      type: type,
                      segment: segment,
                      path: path,
                      pointnumber: i,
                      pathnumber: k
                  };
              }
          }
      }
    }
    return null;
  }
</script>
